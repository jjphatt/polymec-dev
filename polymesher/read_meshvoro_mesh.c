// This implements polymesher's capability for reading polyhedral mesh's 
// generated by Matt Freeman's MeshVoro code.

#include <string.h>
#include "core/polymec.h"
#include "core/interpreter.h"
#include "core/mesh.h"
#include "core/slist.h"

// Lua stuff.
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"

// This data structure represents an intermediate representation of 
// a face in terms of its vertices (instead of edges).
typedef struct 
{
  // A face consists of a connected set of vertices.
  int num_vertices;
  int* vertex_ids;
} face_with_vertices_t;

// This is used to create face objects.
static face_with_vertices_t* face_with_vertices_new(int num_vertices, int* vertices)
{
  ASSERT(num_vertices >= 3);
  ASSERT(vertices != NULL);
  face_with_vertices_t* face = malloc(sizeof(face_with_vertices_t));
  face->num_vertices = num_vertices;
  face->vertex_ids = malloc(sizeof(int) * num_vertices);
  memcpy(face->vertex_ids, vertices, sizeof(int) * num_vertices);
  return face;
}

// This is used to destroy face objects.
static void destroy_face(face_with_vertices_t* face)
{
  free(face->vertex_ids);
  free(face);
}

// This data structure represents an intermediate representation of 
// a cell in terms of its faces.
typedef struct 
{
  char* name; // Element name.
  int index; // (final) cell index.
  int num_faces;
  face_with_vertices_t** faces;
  int* neighbor_ids; // Indices of neighboring cells.
} cell_with_faces_t;

// This is used to create cell objects.
static cell_with_faces_t* cell_with_faces_new(char* name, int index, int num_faces)
{
  ASSERT(index >= 0);
  ASSERT(num_faces >= 4);
  cell_with_faces_t* cell = malloc(sizeof(cell_with_faces_t));
  cell->name = strdup(name);
  cell->index = index;
  cell->num_faces = num_faces;
  cell->faces = malloc(sizeof(face_with_vertices_t*)*num_faces);
  cell->neighbor_ids = malloc(sizeof(int)*num_faces);
  for (int f = 0; f < num_faces; ++f)
  {
    cell->faces[f] = NULL;
    cell->neighbor_ids[f] = -1;
  }
  return cell;
}

// This is used to destroy cell objects.
static void destroy_cell(cell_with_faces_t* cell)
{
  free(cell->name);
  for (int f = 0; f < cell->num_faces; ++f)
    destroy_face(cell->faces[f]);
  free(cell->neighbor_ids);
  free(cell->faces);
  free(cell);
}

// This is used to cleanly destroy linked lists of cells.
static void cell_list_dtor(void* datum)
{
  cell_with_faces_t* cell = datum;
  destroy_cell(cell);
}

static point_t* read_mesh_vertices(FILE* vertex_file, 
                                   int* num_vertices, 
                                   char* error_string)
{
  // Read the points into a linked list.
  int status;
  ptr_slist_t* points_list = ptr_slist_new();
  int last_index = -1;
  do 
  {
    int i;
    double x, y, z;
    status = fscanf(vertex_file, "  %d :  %lE %lE %lE\n", &i, &x, &y, &z);
    if (status != EOF)
    {
      if (status != 4)
      {
        sprintf(error_string, "Error reading line %d of vertex file.", last_index + 2);
        ptr_slist_free(points_list);
        return NULL;
      }

      if (i != (last_index + 1))
      {
        sprintf(error_string, "Vertex indexing is non-contiguous (%d followed %d).", i, last_index);
        ptr_slist_free(points_list);
        return NULL;
      }
      last_index = i;
      point_t* p = point_new(x, y, z);
      ptr_slist_append(points_list, p);
    }
  } while (status != EOF);

  // Translate to an array.
  *num_vertices = points_list->size;
  point_t* vertices = malloc(sizeof(point_t) * points_list->size);
  int i = 0;
  while (!ptr_slist_empty(points_list))
    vertices[i++] = *((point_t*)ptr_slist_pop(points_list, NULL));
  ptr_slist_free(points_list);
  log_detail("read_meshvoro_mesh: Read %d vertices.", *num_vertices);

  return vertices;
}

static cell_with_faces_t** read_mesh_cells(FILE* cell_file, 
                                           int* num_cells, 
                                           char* error_string)
{
  // Read the cells into a linked list.
  int status;
  ptr_slist_t* cells_list = ptr_slist_new();
  int line = 1;
  do 
  {
    // Read the cell header.
    char elem_name[10];
    int cell_index, num_faces;
    status = fscanf(cell_file, "voronoicell: %s number: %d faces: %d\n", 
                    elem_name, &cell_index, &num_faces);
    if (status == EOF) continue; // No more cells
    if (status != 3)
    {
      sprintf(error_string, "Error reading cell header (line %d of cell file).", line);
      ptr_slist_free(cells_list);
      return NULL;
    }
    ++line;

    // Read the index of the generator point in the vertex file.
    // (We don't actually use this information.)
    int center_vertex;
    status = fscanf(cell_file, "center:  %d\n", &center_vertex);
    if (status != 1)
    {
      sprintf(error_string, "Error reading cell center (line %d of cell file).", line);
      ptr_slist_free(cells_list);
      return NULL;
    }
    ++line;

    // Set up a cell representation and append it to our list.
    cell_with_faces_t* cell = cell_with_faces_new(elem_name, cell_index, num_faces);
    ptr_slist_append_with_dtor(cells_list, cell, cell_list_dtor);

    // Read the faces of the cell.
    for (int f = 0; f < num_faces; ++f)
    {
      // Read the number of vertices in the face.
      int num_vertices;
      status = fscanf(cell_file, "vertices in face: %d\n", &num_vertices);
      if (status != 1)
      {
        sprintf(error_string, "Error reading number of face vertices (line %d of cell file).", line);
        ptr_slist_free(cells_list);
        return NULL;
      }
      ++line;

      // Read each of the vertices.
      int face_vertices[num_vertices];
      for (int v = 0; v < num_vertices; ++v)
      {
        status = fscanf(cell_file, "%d\n", &face_vertices[v]);
        if (status != 1)
        {
          sprintf(error_string, "Error reading vertex %d of face %d in cell '%s'\n(line %d of cell file).", v, f, elem_name, line);
          ptr_slist_free(cells_list);
          return NULL;
        }
        ++line;
      }

      // Construct the face.
      cell->faces[f] = face_with_vertices_new(num_vertices, face_vertices);
    }

  } while (status != EOF);

  // Translate to an array.
  *num_cells = cells_list->size;
  cell_with_faces_t** cells = malloc(sizeof(cell_with_faces_t*) * cells_list->size);
  int i = 0;
  while (!ptr_slist_empty(cells_list))
    cells[i++] = (cell_with_faces_t*)ptr_slist_pop(cells_list, NULL);
  ptr_slist_free(cells_list);
  log_detail("read_meshvoro_mesh: Read %d cells.", *num_cells);

  return cells;
}

static int read_cell_neighbors(FILE* neighbor_file,
                               cell_with_faces_t** cells,
                               char* error_string)
{
  return 0;
}

static mesh_t* construct_mesh(cell_with_faces_t** cells, 
                              int num_cells, 
                              point_t* vertices,
                              int num_vertices,
                              char* error_string)
{
  // Count up the faces, edges, and nodes, and assign indices.
  int num_faces = 0, num_edges = 0, num_nodes = 0;

  mesh_t* mesh = mesh_new(num_cells, 0, num_faces, num_edges, num_nodes);
  // FIXME
  return mesh;
}

static mesh_t* mesh_from_meshvoro_files(FILE* cell_file, 
                                        FILE* vertex_file,
                                        FILE* neighbor_file)
{
  point_t* vertices = NULL;
  cell_with_faces_t** cells = NULL;
  char error_str[1024];

  // Read the mesh's vertices into memory.
  int num_vertices;
  vertices = read_mesh_vertices(vertex_file, &num_vertices, error_str);
  if (vertices == NULL) goto error;

  // Read the cell/face information.
  int num_cells;
  cells = read_mesh_cells(cell_file, &num_cells, error_str);
  if (cells == NULL) goto error;

  // Read the neighbor information for cells.
  int err = read_cell_neighbors(neighbor_file, cells, error_str);
  if (err != 0) goto error;

  // Now construct a mesh object.
  mesh_t* mesh = construct_mesh(cells, num_cells, vertices, num_vertices, error_str);
  if (mesh == NULL) goto error;

  // Clean up.
  free(vertices);
  for (int i = 0; i < num_cells; ++i)
    destroy_cell(cells[i]);
  free(cells);

  return mesh;

error:
  if (vertices != NULL) free(vertices);
  if (cells != NULL) 
  {
    for (int i = 0; i < num_cells; ++i)
      destroy_cell(cells[i]);
    free(cells);
  }
  fclose(cell_file);
  fclose(vertex_file);
  fclose(neighbor_file);
  polymec_error(error_str);
  return NULL;
}

// read_meshvoro_mesh(file) -- This function reads a given polyhedral mesh 
// from a file and returns a mesh object.
int read_meshvoro_mesh(lua_State* lua)
{
  // Check the arguments.
  int num_args = lua_gettop(lua);
  if ((num_args != 3) || !lua_isstring(lua, 1) || 
      !lua_isstring(lua, 2) || !lua_isstring(lua, 3))
  {
    lua_pushstring(lua, "read_meshvoro_mesh: invalid arguments. Usage:\n"
                        "mesh = read_meshvoro_mesh(cell_file, vertex_file, neighbor_file)");
    lua_error(lua);
    return LUA_ERRRUN;
  }

  // Get the argument(s).
  const char* cell_filename = lua_tostring(lua, 1);
  const char* vertex_filename = lua_tostring(lua, 2);
  const char* neighbor_filename = lua_tostring(lua, 3);

  // Open the files for reading.
  FILE* cell_file = fopen(cell_filename, "r");
  if (cell_file == NULL)
    polymec_error("Could not open cell file '%s'.", cell_filename);
  FILE* vertex_file = fopen(vertex_filename, "r");
  if (vertex_file == NULL)
    polymec_error("Could not open vertex file '%s'.", vertex_filename);
  FILE* neighbor_file = fopen(neighbor_filename, "r");
  if (neighbor_file == NULL)
    polymec_error("Could not open neighbor file '%s'.", neighbor_filename);

  log_info("read_meshvoro_mesh: Reading inputs:\n"
           "  cell file: %s\n"
           "  vertex file: %s\n"
           "  neighbor file: %s", cell_filename, vertex_filename, neighbor_filename);

  // Read the mesh from the files.
  mesh_t* mesh = mesh_from_meshvoro_files(cell_file, vertex_file, neighbor_file);

  // Close 'em.
  fclose(cell_file);
  fclose(vertex_file);
  fclose(neighbor_file);

  // Push the mesh onto the stack.
  lua_pushmesh(lua, mesh);
  return 1;
}

