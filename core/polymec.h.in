// Copyright (c) 2012-2013, Jeffrey N. Johnson
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this 
// list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, 
// this list of conditions and the following disclaimer in the documentation 
// and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef POLYMEC_H
#define POLYMEC_H

// We only use standard C11 around here. Intel is a bad actor, but we try to 
// accommodate it.
#if !defined(__INTEL_COMPILER) && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L)
#error "Polymec requires a C11-compliant compiler."
#endif

// We require the availability of variable-length arrays, which where 
// mandatory in C99 but are optional in C11.
#if !defined __STDC_NO_VLA__ && __STDC_NO_VLA__ == 1
#error "Polymec requires the availability of variable-length arrays (VLA), which this compiler does not support."
#endif

// In a perfect world, we'd have full support for IEEE 754 floating point 
// arithmetic. The world in which we live is not presently perfect.
//#if !defined __STDC_IEC_559__ || __STDC_IEC_559__ == 0
//#error "Polymec requires IEC 60559 (IEEE 754) floating point arithmetic support."
//#endif

// The Annex K bounds-checking interfaces would be really nice to have, and 
// someday we shall have them, but not today.
//#if !defined __STDC_LIB_EXT1__ || __STDC_LIB_EXT1__ == 0
//#error "Polymec requires the availability of the bounds-checking interfaces in Annex K, which this compiler does not support."
//#endif

// Intel doesn't do C11 stuff, so we have to be clever.
#if defined(__INTEL_COMPILER)
#define noreturn
#else
#include <stdnoreturn.h>
#endif

#include <strings.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <inttypes.h> // for printing uint64_t, etc.
#include <string.h>
#include <math.h>
#include <limits.h>
#include <stddef.h>
#include <float.h>
#include <time.h>

#include <mpi.h>

// Real number representation.
typedef @POLYMEC_REAL_TYPE@ real_t;
#define POLYMEC_HAVE_SINGLE_PRECISION @HAVE_SINGLE_PRECISION@
#define POLYMEC_HAVE_DOUBLE_PRECISION @HAVE_DOUBLE_PRECISION@
#define POLYMEC_PRECISION @POLYMEC_PRECISION@
#define MPI_REAL_T @POLYMEC_MPI_REAL_TYPE@

// Bad Fortran! No biscuit!
#ifdef MPI_REAL
#undef MPI_REAL
#endif

// This returns the minimum of a and b.
#ifndef MIN
#define MIN(a, b) ((a < b) ? a : b)
#endif

// This returns the maximum of a and b.
#ifndef MAX
#define MAX(a, b) ((a > b) ? a : b)
#endif

// This returns the sign (+1/-1) of the given quantity x.
#define SIGN(x) ((x > 0) ? 1 : (x < 0) ? -1 : 0)

// Use polymec_unreachable() to tell the C compiler that a line in a function 
// can never be reached.
#if defined(__clang__) || defined(__GNUC__)
// Both Clang and GNU have __builtin_unreachable.
#define polymec_unreachable __builtin_unreachable
#else
#define polymec_unreachable()
#endif

// Global indices are unsigned 64-bit integers.
typedef uint64_t index_t;
#ifndef MPI_INDEX_T
#define MPI_INDEX_T MPI_INT64_T
#endif

// Configuration information
#define POLYMEC_HAVE_MPI @HAVE_MPI@
#define POLYMEC_HAVE_TETGEN @HAVE_TETGEN@
#define POLYMEC_C_COMPILER "@CMAKE_C_COMPILER@"
#define POLYMEC_INCLUDE_DIR "@PROJECT_BINARY_DIR@/include"

// The C standard no longer defines M_PI(!!!!). 
// So we have to provide it ourselves.
#ifndef M_PI
#include <float.h>
#define M_PI 3.1415926535897932384626433832795L
#if LDBL_DIG > 32
#error "Definition of PI doesn't use the full precision of long double"
#endif
#endif

// Some macros.
#ifndef NDEBUG
#define ASSERT(x) \
  if (!(x)) \
    polymec_abort("Assertion %s failed\nat %s: %d\n", #x, __FILE__, __LINE__);
#else
#define ASSERT(x) 
#endif

// This converts a destructor function for a specific type to a generic
// void (*dtor)(void*) destructor.
#define DTOR(x) ((void (*)(void*))(x))

// Here's a macro that fills an array with the given values.
#define FILL_ARRAY(array, start, num, val) \
for (int i = start; i < start + num; ++i) \
  array[i] = val

#include "core/allocators.h"
#include "core/logging.h"
#include "core/arch.h"
#include "core/string_utils.h"
#include "core/file_utils.h"

typedef void (*polymec_error_handler_function)(const char*);

// Issues an error with the given message. By default, an error issues a 
// message to stdout and exits the program with status -1.
noreturn void polymec_error(const char* message, ...);

// Aborts execution in a proper manner that respects MPI if needed, 
// writing the given message to stderr.
noreturn void polymec_abort(const char* message, ...);

// Sets the error handler for the polymec library.
void polymec_set_error_handler(polymec_error_handler_function handler);

// Issues a warning to stderr.
void polymec_warn(const char* message, ...);

// This function enables floating point exceptions where available.
void polymec_enable_fpe();

// This function disables floating point exceptions.
void polymec_disable_fpe();

// This function suspends all currently-enabled floating point exceptions. 
// They can be restored later with polymec_restore_fpe_exceptions().
void polymec_suspend_fpe();

// This function restores the exceptions that were suspended by a prior call 
// to polymec_suspend_fpe_exceptions.
void polymec_restore_fpe();

// Call this function to indicate that something is not implemented
// with a fatal exit.
noreturn void polymec_not_implemented(const char* component);

// Initialize polymec's services. If polymec has already been initialized, 
// this does nothing.
void polymec_init(int argc, char** argv);

// Register a function to be called upon exit.
void polymec_atexit(void (*func)());

// This function writes version information to the given file descriptor.
void polymec_version_fprintf(const char* exe_name, FILE* stream);

// This function writes provenance information to the given file descriptor.
void polymec_provenance_fprintf(FILE* stream);

// Returns an internal string containing the command that invoked the 
// present instance of a polymec application.
const char* polymec_invocation();

// Returns the time at which the present instance of a polymec application 
// was invoked.
time_t polymec_invocation_time();

// This function returns the number of cores on the system, or 1 if it cannot
// be determined.
int polymec_num_cores();

// Use this macro to indicate that something hasn't been implemented.
#define POLYMEC_NOT_IMPLEMENTED polymec_error("%s: line %d: Not implemented!", __FILE__, __LINE__);

#endif
