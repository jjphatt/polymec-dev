// Copyright (c) 2012-2013, Jeffrey N. Johnson
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this 
// list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, 
// this list of conditions and the following disclaimer in the documentation 
// and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef POLYMEC_H
#define POLYMEC_H

// We only use standard C11 around here.
#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L
#error "Polymec requires a C11-compliant compiler."
#endif

// We require the availability of variable-length arrays, which where 
// mandatory in C99 but are optional in C11.
#if !defined __STDC_NO_VLA__ && __STDC_NO_VLA__ == 1
#error "Polymec requires the availability of variable-length arrays (VLA), which this compiler does not support."
#endif

// The Annex K bounds-checking interfaces would be really nice to have, and 
// someday we shall have them, but not today.
//#if !defined __STDC_LIB_EXT1__ || __STDC_LIB_EXT1__ == 0
//#error "Polymec requires the availability of the bounds-checking interfaces in Annex K, which this compiler does not support."
//#endif

#include <strings.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <stddef.h>
#include <float.h>
#include <time.h>

#include <mpi.h>

#include "core/logging.h"
#include "core/arch.h"
#include "core/string_utils.h"

// Configuration information
#define POLYMEC_HAVE_MPI @HAVE_MPI@
#define POLYMEC_HAVE_TETGEN @HAVE_TETGEN@
#define POLYMEC_C_COMPILER "@CMAKE_C_COMPILER@"
#define POLYMEC_INCLUDE_DIR "@PROJECT_BINARY_DIR@/include"

// The C99 standard no longer defines M_PI(!!!!). 
// So we have to provide it ourselves.
#ifndef M_PI
#include <float.h>
#define M_PI 3.1415926535897932384626433832795L
#if LDBL_DIG > 32
#error "Definition of PI doesn't use the full precision of long double"
#endif
#endif

// Some macros.
#ifndef NDEBUG
#if USE_MPI
#define ASSERT(x) \
  if (!(x)) \
  { \
    printf("Assertion %s failed\nat %s: %d\n", #x, __FILE__, __LINE__); \
    MPI_Abort(MPI_COMM_WORLD, -1); \
  }
#else
#define ASSERT(x) \
  if (!(x)) \
  { \
    printf("Assertion %s failed\nat %s: %d\n", #x, __FILE__, __LINE__); \
    abort(); \
  }
#endif
#else
#define ASSERT(x) 
#endif

// This macro allows us to explicate that a function argument is not used
// in a C-friendly way. Some people point out that using this macro with 
// a "volatile" variable changes the structure of memory barriers. Perhaps 
// now you understand why polymec isn't intended to be thread-safe.
#ifndef UNUSED_ARG
#define UNUSED_ARG(x) (void)(x)
#endif

// This converts a destructor function for a specific type to a generic
// void (*dtor)(void*) destructor.
#define DTOR(x) ((void (*)(void*))(x))

// Here's a macro that fills an array with the given values.
#define FILL_ARRAY(array, start, num, val) \
for (int i = start; i < start + num; ++i) \
  array[i] = val

// Real number representation.
typedef @POLYMEC_REAL_TYPE@ real_t;
#define POLYMEC_HAVE_SINGLE_PRECISION @HAVE_SINGLE_PRECISION@
#define POLYMEC_HAVE_DOUBLE_PRECISION @HAVE_DOUBLE_PRECISION@
#define POLYMEC_PRECISION @POLYMEC_PRECISION@
#ifndef MPI_REAL
#define MPI_REAL @POLYMEC_MPI_REAL_TYPE@
#endif

// This returns the minimum of a and b.
#ifndef MIN
#define MIN(a, b) ((a < b) ? a : b)
#endif

// This returns the maximum of a and b.
#ifndef MAX
#define MAX(a, b) ((a > b) ? a : b)
#endif

// This returns the sign (+1/-1) of the given quantity x.
#define SIGN(x) ((x > 0) ? 1 : (x < 0) ? -1 : 0)

// Real-valued square root function.
static inline real_t rsqrt(real_t x)
{
  return (real_t)sqrt((double)x);
}

// These macros use the given arena to allocate/free memory and fall back 
// to the heap if the first argument is NULL. Note that you still have to 
// #include <arena/arena.h> to use them.
#define ARENA_MALLOC(arena, size, alignment) \
  (arena != NULL) ? arena_malloc(arena, size, alignment) : malloc(size)

#define ARENA_REALLOC(arena, memory, size, alignment) \
  (arena != NULL) ? arena_realloc(arena, memory, size, alignment) : realloc(memory, size)

#define ARENA_FREE(arena, memory) \
  (arena != NULL) ? arena_free(arena, memory) : free(memory)

// Error codes.
#define POLYMEC_SUCCESS 0
#define POLYMEC_FAILURE -1
#define POLYMEC_NO_EFFECT 1

typedef int (*polymec_error_handler_function)(const char*);

// Issues an error with the given message. By default, an error issues a 
// message to stdout and exits the program with status -1.
int polymec_error(const char* message, ...);

// Sets the error handler for the polymec library.
void polymec_set_error_handler(polymec_error_handler_function handler);

// Issues a warning to stderr.
void polymec_warn(const char* message, ...);

// This function enables floating point exceptions where available.
void polymec_enable_fpe_exceptions();

// This function disables floating point exceptions.
void polymec_disable_fpe_exceptions();

// This function suspends all currently-enabled floating point exceptions. 
// They can be restored later with polymec_restore_fpe_exceptions().
void polymec_suspend_fpe_exceptions();

// This function restores the exceptions that were suspended by a prior call 
// to polymec_suspend_fpe_exceptions.
void polymec_restore_fpe_exceptions();

// Call this function to indicate that something is not implemented
// with a fatal exit.
void polymec_not_implemented(const char* component);

// Initialize polymec's services. If polymec has already been initialized, 
// this does nothing.
void polymec_init(int argc, char** argv);

// Register a function to be called upon exit.
void polymec_atexit(void (*func)());

// This function writes version information to the given file descriptor.
void polymec_version_fprintf(const char* exe_name, FILE* stream);

// This function writes provenance information to the given file descriptor.
void polymec_provenance_fprintf(FILE* stream);

// Returns an internal string containing the command that invoked the 
// present instance of a polymec application.
const char* polymec_invocation();

// Returns the time at which the present instance of a polymec application 
// was invoked.
time_t polymec_invocation_time();

// This function returns the number of cores on the system, or 1 if it cannot
// be determined.
int polymec_num_cores();

// Use this macro to indicate that something hasn't been implemented.
#define POLYMEC_NOT_IMPLEMENTED polymec_error("%s: line %d: Not implemented!", __FILE__, __LINE__);

#endif
