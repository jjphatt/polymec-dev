// Copyright (c) 2012-2013, Jeffrey N. Johnson
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice, this 
// list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright notice, 
// this list of conditions and the following disclaimer in the documentation 
// and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef POLYMEC_H
#define POLYMEC_H

// We only use standard C11 around here.
#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L
#error "Polymec requires a C11-compliant compiler."
#endif

// We require the availability of variable-length arrays, which where 
// mandatory in C99 but are optional in C11.
#if !defined __STDC_NO_VLA__ && __STDC_NO_VLA__ == 1
#error "Polymec requires the availability of variable-length arrays (VLA), which this compiler does not support."
#endif

// In a perfect world, we'd have full support for IEEE 754 floating point 
// arithmetic. The world in which we live is not presently perfect.
//#if !defined __STDC_IEC_559__ || __STDC_IEC_559__ == 0
//#error "Polymec requires IEC 60559 (IEEE 754) floating point arithmetic support."
//#endif

// The Annex K bounds-checking interfaces would be really nice to have, and 
// someday we shall have them, but not today.
//#if !defined __STDC_LIB_EXT1__ || __STDC_LIB_EXT1__ == 0
//#error "Polymec requires the availability of the bounds-checking interfaces in Annex K, which this compiler does not support."
//#endif

#include <strings.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdnoreturn.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <stddef.h>
#include <float.h>
#include <time.h>

#include <mpi.h>

#include "arena/proto.h"

#include "core/logging.h"
#include "core/arch.h"
#include "core/string_utils.h"
#include "core/file_utils.h"

// Configuration information
#define POLYMEC_HAVE_MPI @HAVE_MPI@
#define POLYMEC_HAVE_TETGEN @HAVE_TETGEN@
#define POLYMEC_C_COMPILER "@CMAKE_C_COMPILER@"
#define POLYMEC_INCLUDE_DIR "@PROJECT_BINARY_DIR@/include"

// The C standard no longer defines M_PI(!!!!). 
// So we have to provide it ourselves.
#ifndef M_PI
#include <float.h>
#define M_PI 3.1415926535897932384626433832795L
#if LDBL_DIG > 32
#error "Definition of PI doesn't use the full precision of long double"
#endif
#endif

// Some macros.
#ifndef NDEBUG
#define ASSERT(x) \
  if (!(x)) \
    polymec_abort("Assertion %s failed\nat %s: %d\n", #x, __FILE__, __LINE__);
#else
#define ASSERT(x) 
#endif

// This converts a destructor function for a specific type to a generic
// void (*dtor)(void*) destructor.
#define DTOR(x) ((void (*)(void*))(x))

// Here's a macro that fills an array with the given values.
#define FILL_ARRAY(array, start, num, val) \
for (int i = start; i < start + num; ++i) \
  array[i] = val

// Real number representation.
typedef @POLYMEC_REAL_TYPE@ real_t;
#define POLYMEC_HAVE_SINGLE_PRECISION @HAVE_SINGLE_PRECISION@
#define POLYMEC_HAVE_DOUBLE_PRECISION @HAVE_DOUBLE_PRECISION@
#define POLYMEC_PRECISION @POLYMEC_PRECISION@
#ifndef MPI_REAL
#define MPI_REAL @POLYMEC_MPI_REAL_TYPE@
#endif

// This returns the minimum of a and b.
#ifndef MIN
#define MIN(a, b) ((a < b) ? a : b)
#endif

// This returns the maximum of a and b.
#ifndef MAX
#define MAX(a, b) ((a > b) ? a : b)
#endif

// This returns the sign (+1/-1) of the given quantity x.
#define SIGN(x) ((x > 0) ? 1 : (x < 0) ? -1 : 0)

// Real-valued square root function.
static inline real_t rsqrt(real_t x)
{
  return (real_t)sqrt((double)x);
}

// This type represents a memory allocator which services memory allocations 
// and deallocations. There are two kinds of allocators: an "arena," which 
// represents a contiguous block of memory in the heap which grows as needed, 
// and a "pool," which allocates pools of memory of fixed sizes.
typedef struct polymec_allocator_t polymec_allocator_t;

// Returns an arena allocator.
polymec_allocator_t* arena_allocator_new();

// Returns a pool allocator.
polymec_allocator_t* pool_allocator_new();

// Destroys the given allocator.
void polymec_allocator_free(polymec_allocator_t* alloc);

// This function allocates memory in the same fashion as malloc(), using the 
// allocator on the top of polymec's allocator stack. If the stack is empty, 
// calls to polymec_malloc() simply use malloc().
void* polymec_malloc(size_t size);

// This version of polymec_malloc() returns memory with the given alignment 
// using the allocator on the top of the allocator stack, or calls 
// aligned_alloc() if the stack is empty.
void* polymec_aligned_alloc(size_t alignment, size_t size);

// This reallocates existing memory using the allocator on top of the allocator 
// stack, or calls realloc() if the stack is empty.
void* polymec_realloc(void* memory, size_t size);

// This version of polymec_realloc guarantees the given alignment of the 
// reallocated memory, and using the allocator on top of the allocator stack. 
// If the stack is empty, a fatal error is issued, since there is no 
// portable way to perform an aligned realloc with the standard C allocator.
void* polymec_aligned_realloc(void* memory, size_t alignment, size_t size);

// Frees memory, returning it to the allocator on top of the allocator stack 
// (or calling free() if the stack is empty).
void polymec_free(void* memory);

// Pushes a new memory allocator to the allocator stack, using this allocator 
// to allocate all memory with polymec_malloc() until it is popped.
void push_allocator(polymec_allocator_t* allocator);

// Pops an allocator off of the stack, returning it and using the next one to 
// allocate all memory with polymec_malloc(). 
polymec_allocator_t* pop_allocator();

typedef void (*polymec_error_handler_function)(const char*);

// Issues an error with the given message. By default, an error issues a 
// message to stdout and exits the program with status -1.
noreturn void polymec_error(const char* message, ...);

// Aborts execution in a proper manner that respects MPI if needed, 
// writing the given message to stderr.
noreturn void polymec_abort(const char* message, ...);

// Sets the error handler for the polymec library.
void polymec_set_error_handler(polymec_error_handler_function handler);

// Issues a warning to stderr.
void polymec_warn(const char* message, ...);

// This function enables floating point exceptions where available.
void polymec_enable_fpe_exceptions();

// This function disables floating point exceptions.
void polymec_disable_fpe_exceptions();

// This function suspends all currently-enabled floating point exceptions. 
// They can be restored later with polymec_restore_fpe_exceptions().
void polymec_suspend_fpe_exceptions();

// This function restores the exceptions that were suspended by a prior call 
// to polymec_suspend_fpe_exceptions.
void polymec_restore_fpe_exceptions();

// Call this function to indicate that something is not implemented
// with a fatal exit.
noreturn void polymec_not_implemented(const char* component);

// Initialize polymec's services. If polymec has already been initialized, 
// this does nothing.
void polymec_init(int argc, char** argv);

// Register a function to be called upon exit.
void polymec_atexit(void (*func)());

// This function writes version information to the given file descriptor.
void polymec_version_fprintf(const char* exe_name, FILE* stream);

// This function writes provenance information to the given file descriptor.
void polymec_provenance_fprintf(FILE* stream);

// Returns an internal string containing the command that invoked the 
// present instance of a polymec application.
const char* polymec_invocation();

// Returns the time at which the present instance of a polymec application 
// was invoked.
time_t polymec_invocation_time();

// This function returns the number of cores on the system, or 1 if it cannot
// be determined.
int polymec_num_cores();

// Use this macro to indicate that something hasn't been implemented.
#define POLYMEC_NOT_IMPLEMENTED polymec_error("%s: line %d: Not implemented!", __FILE__, __LINE__);

#endif
