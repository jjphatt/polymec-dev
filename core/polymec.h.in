// Copyright (c) 2012-2015, Jeffrey N. Johnson
// All rights reserved.
// 
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef POLYMEC_H
#define POLYMEC_H

// We only use standard C11 around here. Intel is a bad actor, but we try to 
// accommodate it.
#if !defined(__INTEL_COMPILER) && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L) && !defined(__cplusplus)
#error "Polymec requires a C11-compliant compiler."
#endif

// We require the availability of variable-length arrays, which where 
// mandatory in C99 but are optional in C11.
#if defined(__STDC_NO_VLA__) && __STDC_NO_VLA__ == 1
#error "Polymec requires the availability of variable-length arrays (VLA), which this compiler does not support."
#endif

// In a perfect world, we'd have full support for IEEE 754 floating point 
// arithmetic. The world in which we live is not presently perfect.
//#if !defined(__STDC_IEC_559__) || __STDC_IEC_559__ == 0
//#error "Polymec requires IEC 60559 (IEEE 754) floating point arithmetic support."
//#endif

// The Annex K bounds-checking interfaces would be really nice to have, and 
// someday we shall have them, but not today.
//#if !defined(__STDC_LIB_EXT1__) || __STDC_LIB_EXT1__ == 0
//#error "Polymec requires the availability of the bounds-checking interfaces in Annex K, which this compiler does not support."
//#endif

// Intel doesn't do C11 stuff, so we have to be clever.
#if defined(__INTEL_COMPILER) || defined(__cplusplus)
#define noreturn
#else
#include <stdnoreturn.h>
#endif

#include <strings.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <ctype.h>
#include <inttypes.h> // for printing uint64_t, etc.
#include <string.h>
#include <math.h>
#include <limits.h>
#include <stddef.h>
#include <float.h>
#include <time.h>

#include <mpi.h>

// Real number representation. 
#define POLYMEC_HAVE_SINGLE_PRECISION @HAVE_SINGLE_PRECISION@
#define POLYMEC_HAVE_DOUBLE_PRECISION @HAVE_DOUBLE_PRECISION@
#define POLYMEC_PRECISION @POLYMEC_PRECISION@
#define MPI_REAL_T @POLYMEC_MPI_REAL_TYPE@

// Shared library support.
#define POLYMEC_HAVE_SHARED_LIBS @HAVE_SHARED_LIBS@
#define SHARED_LIBRARY_SUFFIX "@CMAKE_SHARED_LIBRARY_SUFFIX@"

// Valgrind support.
#define POLYMEC_HAVE_VALGRIND @VALGRIND_FOUND@

// In defining real_t, we have to accommodate Metis, which defines 
// its own.
#ifdef _METIS_H_
#if POLYMEC_HAVE_SINGLE_PRECISION && REALTYPEWIDTH != 32
#error "real_t defined in metis.h disagrees with our definition (float)."
#elif POLYMEC_HAVE_DOUBLE_PRECISION && REALTYPEWIDTH != 64
#error "real_t defined in metis.h disagrees with our definition (double)."
#endif
#else
typedef @POLYMEC_REAL_TYPE@ real_t;
#endif


// Bad Fortran! No biscuit!
#ifdef MPI_REAL
#undef MPI_REAL
#endif

// This returns the minimum of a and b.
#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif

// This returns the maximum of a and b.
#ifndef MAX
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#endif

// This returns the absolute value of a.
#ifndef ABS
#define ABS(a) (((a) >= 0.0) ? (a) : -(a))
#endif

// This returns the sign (+1/-1) of the given quantity x.
#define SIGN(x) (((x) > 0) ? 1 : ((x) < 0) ? -1 : 0)

// Machine epsilon.
#ifndef REAL_EPSILON

#if POLYMEC_HAVE_DOUBLE_PRECISION
#define REAL_EPSILON DBL_EPSILON
#define REAL_MAX DBL_MAX
#define REAL_MIN DBL_MIN
#else
#define REAL_EPSILON FLT_EPSILON
#define REAL_MAX FLT_MAX
#define REAL_MIN FLT_MIN
#endif

#endif

// Use polymec_unreachable() to tell the C compiler that a line in a function 
// can never be reached.
#if defined(__clang__) || defined(__GNUC__)
// Both Clang and GNU have __builtin_unreachable.
#define polymec_unreachable __builtin_unreachable
#else
#define polymec_unreachable()
#endif

// Global indices are unsigned 64-bit integers.
typedef uint64_t index_t;
#ifndef MPI_INDEX_T
#define MPI_INDEX_T MPI_INT64_T
#endif

// Configuration information
#define POLYMEC_HAVE_MPI @HAVE_MPI@
#define POLYMEC_HAVE_OPENMP @HAVE_OPENMP@
#define POLYMEC_C_COMPILER "@CMAKE_C_COMPILER@"
#define POLYMEC_INCLUDE_DIR "@PROJECT_BINARY_DIR@/include"

// The C standard no longer defines M_PI(!!!!). 
// So we have to provide it ourselves.
#ifndef M_PI
#include <float.h>
#define M_PI (real_t)(3.1415926535897932384626433832795L)
#if LDBL_DIG > 32
#error "Definition of PI doesn't use the full precision of long double"
#endif
#endif

// Some macros.
#ifndef NDEBUG
#define ASSERT(x) \
  if (!(x)) \
    polymec_abort("Assertion %s failed\nat %s: %d\n", #x, __FILE__, __LINE__);
#else
#define ASSERT(x) 
#endif

// This converts a destructor function for a specific type to a generic
// void (*dtor)(void*) destructor.
#define DTOR(x) ((void (*)(void*))(x))

// Here's a macro that fills an array with the given values.
#define FILL_ARRAY(array, start, num, val) \
for (int i = start; i < start + num; ++i) \
  array[i] = val

// This BOUNDS macro returns the bounds of a given dimension in a multidimensional array.
#define BOUNDS(a) ((sizeof(a)) / (sizeof ((a)[0])))

#include "core/allocators.h"
#include "core/logging.h"
#include "core/arch.h"
#include "core/string_utils.h"
#include "core/file_utils.h"

typedef void (*polymec_error_handler_function)(const char*);

// Issues an error with the given message. By default, an error issues a 
// message to stdout and exits the program with status -1.
noreturn void polymec_error(const char* message, ...);

// Aborts execution in a proper manner that respects MPI if needed, 
// writing the given message to stderr.
noreturn void polymec_abort(const char* message, ...);

// Sets the error handler for the polymec library.
void polymec_set_error_handler(polymec_error_handler_function handler);

// Issues a warning to stderr.
void polymec_warn(const char* message, ...);

// This function enables floating point exceptions where available.
void polymec_enable_fpe(void);

// This function disables floating point exceptions.
void polymec_disable_fpe(void);

// This function suspends all currently-enabled floating point exceptions. 
// They can be restored later with polymec_restore_fpe.
void polymec_suspend_fpe(void);

// This function restores the exceptions that were suspended by a prior call 
// to polymec_suspend_fpe.
void polymec_restore_fpe(void);

// Call this function to indicate that something is not implemented
// with a fatal exit.
noreturn void polymec_not_implemented(const char* component);

// This registers a function to be called by polymec_init, after all of 
// polymec's services have been started. This function gets passed argc and 
// argv, and can make use of polymec's environment.
// Use this function sparingly: currently only 32 functions may be registered 
// in this fashion.
void polymec_atinit(void (*func)(int argc, char** argv));

// Initializes polymec's services. In particular:
// * If MPI has not been initialized, polymec will assume responsibility 
//   for initializing and finalizing it.
// * Timers are started if requested on the command line.
// * Logging is started at the default level (or that requested).
// * A signal handler is set up for SIGINT that cleanly shuts down polymec.
// * Any functions registered using polymec_atinit are called.
// If polymec has already been initialized, this does nothing.
void polymec_init(int argc, char** argv);

// Registers a function to be called upon exit.
// Use this function sparingly: currently only 32 functions may be registered 
// in this fashion.
void polymec_atexit(void (*func)(void));

// This function writes version information to the given file descriptor.
void polymec_version_fprintf(const char* exe_name, FILE* stream);

// This function writes provenance information to the given file descriptor.
void polymec_provenance_fprintf(FILE* stream);

// Returns an internal string containing the actual name of the executable 
// polymec application. This string contains just the name of the executable, 
// without any path information.
const char* polymec_executable_name(void);

// Returns an internal string containing the command that invoked the 
// present instance of a polymec application.
const char* polymec_invocation(void);

// Returns the time at which the present instance of a polymec application 
// was invoked.
time_t polymec_invocation_time(void);

// Call this function with a string to append additional information for 
// provenance.
void polymec_append_provenance_data(const char* provenance_data);

// This function returns the number of cores on the system, or 1 if it cannot
// be determined.
int polymec_num_cores(void);

// This function returns true if polymec is running in a valgrind process,
// false if not.
bool polymec_running_in_valgrind(void);

// This function returns true if |a - b| < epsilon, false otherwise. Here, 
// epsilon is polymec's floating point tolerance, set by default to 1e-50,
// and otherwise by set_real_epsilon.
static real_t _polymec_epsilon = 1e-50;
static inline bool reals_equal(real_t a, real_t b)
{
  return (ABS(a - b) < _polymec_epsilon);
}

// This function sets polymec's floating point tolerance.
static inline void set_real_epsilon(real_t epsilon)
{
  _polymec_epsilon = epsilon;
}

// This function returns true if |a - b| < epsilon, false otherwise. 
static inline bool reals_nearly_equal(real_t a, real_t b, real_t epsilon)
{
  return (ABS(a - b) < epsilon);
}

// Use this macro to indicate that something hasn't been implemented.
#define POLYMEC_NOT_IMPLEMENTED polymec_error("%s:\n  line %d: Function %s is not implemented!", __FILE__, __LINE__, __func__);

// Use this macro to indicate that the current function is deprecated.
#define POLYMEC_DEPRECATED log_urgent("%s:\n line %d: Function %s is deprecated.", __FILE__, __LINE__, __func__);

#endif
