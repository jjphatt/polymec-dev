\documentclass[12pt]{article}

\tolerance=750

%\input{../Common/fontset.tex}
%\input{../Common/preamble.tex}
%\input{../Common/macros.tex}

\usepackage{makeidx}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{url} % For web pages
\usepackage{listings} % For source code with captions.
\lstset{numbers=left, stepnumber=2, frame=single, basicstyle=\footnotesize}

% Useful Commands
\newcommand{\labelSec}[1]{\label{sec:#1}}
\newcommand{\labelEq}[1]{\label{eq:#1}}
\newcommand{\labelFig}[1]{\label{fig:#1}}
\newcommand{\labelTab}[1]{\label{tab:#1}}
\newcommand{\labelApp}[1]{\label{app:#1}}
\newcommand{\labelListing}[1]{\label{listing:#1}}
\newcommand{\refEq}[1]{(\ref{eq:#1})}
\newcommand{\refFig}[1]{Figure \ref{fig:#1}}
\newcommand{\refSec}[1]{Section \ref{sec:#1}}
\newcommand{\refTab}[1]{Table \ref{tab:#1}}
\newcommand{\refApp}[1]{Appendix \ref{app:#1}}
\newcommand{\refListing}[1]{Listing \ref{listing:#1}}
\newcommand{\polymec}{\textsc{polymec} }
\newcommand{\newEq}[2]{\begin{equation} \label{eq:#1} #2 \end{equation}}

% Mathy math.
\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\tens}[1]{\mathbf{#1}}
\newcommand{\ddx}[1]{\frac{\partial #1}{\partial x}}
\newcommand{\ddy}[1]{\frac{\partial #1}{\partial y}}
\newcommand{\ddz}[1]{\frac{\partial #1}{\partial z}}
\newcommand{\ddt}[1]{\frac{\partial #1}{\partial t}}
\newcommand{\DDt}[1]{\frac{\text{d}#1}{\text{d}t}}
\newcommand{\ddr}[1]{\frac{\partial #1}{\partial r}}
\newcommand{\diverg}[1]{\nabla\cdot#1}
\newcommand{\grad}[1]{\nabla#1}
\newcommand{\curl}[1]{\nabla \times #1}
\newcommand{\laplacian}[1]{\nabla^2 #1}
\newcommand{\half}{\small\frac{1}{2}}
\newcommand{\dV}{~\mathrm{d}V}
\newcommand{\dS}{~\mathrm{d}S}
\DeclareMathOperator{\trace}{Tr}
\DeclareMathOperator{\erf}{erf}
\DeclareMathOperator{\sgn}{sgn}

% Make pdflatex act like latex.
%\pdfadjustspacing=1

\title{Polymec's poisson model}
\author{Jeffrey Johnson \\ 
jjphatt@gmail.com}

\makeindex % tell \index to actually write the .idx file

\begin{document}

\maketitle

%\input{disclaimer.tex} 

\section{Overview}\labelSec{Overview}

On the grounds that one must crawl before one limps, we wish to construct a 
\polymec model for solving Poisson's equation and some simple variants. This 
equation, which is one of the oldest and most richly-studied partial differential 
equations, is usually written as

\begin{equation}
\laplacian{\phi} = \rho \labelEq{poissonEq}
\end{equation}

\noindent
where $\phi$ is the solution to \refEq{poissonEq} on some domain $\Omega$, 
subject to some set of boundary conditions on its surface $\Gamma = \partial\Omega$, 
and $\rho$ is some source term that may vary in space.

This equation has several applications. In vacuum electrostatics, it is used to find 
an electric field caused by a potential gradient, $\vec{E} = -\grad{\phi}$, 
using Gauss's Law $\diverg{\vec{E}} = \rho/\epsilon_0$, where $\rho$ is a volumetric 
charge density. Newton's classical law of gravitation may be written in terms of a 
gravitational potential $\phi$ for which the acceleration is its gradient and 
the source term $\rho$ is the density of mass in space. Similarly, the steady 
state of heat transfer in a homogeneous medium also reduces to \refEq{poissonEq}, 
with the $\phi$ representing the temperature and $\rho$ representing heat sources.

Generalizing this equation a bit allows us to accommodate even more applications. 
The electric field in a dielectric medium can be found by solving the equation 
$\diverg{(\epsilon \vec{E})} = \rho_{f}$, where $\epsilon$ is the electric 
permeability in the medium, and $\rho_{f}$ is the density of free charges. 
The steady state heat equation for a medium with variable conductivity $\lambda$ 
becomes $\diverg{(\lambda \grad{\phi})} = \rho$.

\subsection*{Boundary conditions}

Poisson's equation accommodates a number of basic boundary conditions on the 
solution field $\phi$ on the surface of the domain $\Gamma$:

\begin{enumerate}
 \item A {\em Dirichlet} boundary condition prescribes the value of $\phi$ on $\Gamma$:
 \begin{equation}
 \phi(\vec{x}) = \phi_D(\vec{x}), ~~\vec{x} \in \Gamma \labelEq{dirichletBC}
 \end{equation}
 \item A {\em Neumann} boundary condition prescribes a derivative of $\phi$ on $\Gamma$.
       Many researchers use this term to describe conditions on normal and/or tangential 
       derivatives with a scalar factor, using the normal vector $\vec{n}$. We will focus on normal derivatives, i.e.
 \begin{equation}
 \vec{n}\cdot\grad{\phi}\large|_\vec{x} = \phi_N, ~~\vec{x} \in \Gamma \labelEq{neumannBC}
 \end{equation}
 \item A {\em Robin} boundary condition prescribes the value of a linear combination of $\phi$ 
       and its derivative on the surface $\Gamma$. In the above, language, this is
 \begin{equation}
 \alpha\phi(\vec{x}) + \beta\left(\vec{n}\cdot\grad{\phi}\large|_\vec{x}\right) = \phi_R, ~~\vec{x} \in \Gamma \labelEq{robinBC}
 \end{equation}
 \noindent
 where $\alpha$ and $\beta$ are parameters that usually correspond to physical aspects of the 
 boundary condition. Note that \refEq{dirichletBC} and \refEq{neumannBC} are special cases of 
 \refEq{robinBC}.
\end{enumerate}

\subsection*{Model Equations}

With all this in mind, we can express the equations we wish to capture in a \polymec model 
as the following partial differential equation with a solution $\phi(\vec{x}, t)$, 
defined on the domain $\Omega$ with a boundary $\Gamma = \partial\Omega = \bigcup(\Gamma_D, \Gamma_N, \Gamma_R)$, 
with the various $\Gamma$ regions corresponding to different boundary conditions:

\begin{align}
\diverg\left[\lambda(\vec{x}, t)\grad{\phi}\right] &= \rho(\vec{x}, t), ~~\vec{x} \in \Omega \labelEq{modelEq} \\
\phi(\vec{x}, t) &= \phi_D(\vec{x}, t), ~~\vec{x} \in \Gamma_D, \notag \\
\vec{n}\cdot\grad{\phi(\vec{x}, t)} &= \phi_N(\vec{x}, t), ~~\vec{x} \in \Gamma_N \notag \\
\alpha(\vec{x}, t)\phi(\vec{x}, t) + \beta(\vec{x}, t)\left[\vec{n}\cdot\grad{\phi(\vec{x}, t)}\right] &= \phi_R(\vec{x}, t), ~~\vec{x} \in \Gamma_R \notag
\end{align}

\noindent
Here, we have added a parameter $t$ to represent a time in a simulation, which allows us to 
make use of time-dependent source functions and boundary conditions for various model problems. 
We have also allowed the parameters $\lambda$, $\alpha$ and $\beta$ to vary in space and time.

\section{Numerical Formulations}\labelSec{Numerics}

\polymec targets two different numerical formulations for its applications:

\begin{enumerate}
 \item Finite-volume methods on arbitrary polyhedral meshes (FV).
 \item Finite-volume-like methods on point clouds that use neighbor searches 
       to construct topological relationships in lieu of a mesh. The particular 
       family of methods we are concerned with here are known as {\em Finite Volume Particle Methods} (FVPM), 
       described in \cite{Hietel2000}, \cite{Teleaga2005}, and \cite{Nestor2009}.
\end{enumerate}

\noindent
We describe approaches for each of these formulations in this section.

\subsection{FV formulation}

In the finite volume approach, the domain $\Omega$ is partitioned into a set of 
cells $\mathcal{C}$ in a polyhedral mesh. A cell is joined to each of its neighboring 
cells by a face, unless it is on the boundary of the problem, where it is bounded by 
a face with no opposite cell. A face is bounded by a set of edges that separate them 
from neighboring faces, and each edge is bounded by two nodes. The nodes are defined
by their (three-dimensional) spatial coordinates. The sets of faces, edges, and nodes in 
a mesh are written $\mathcal{F}$, $\mathcal{E}$, and $\mathcal{N}$, respectively.

We begin by integrating \refEq{modelEq} over the entire domain $\Omega$ and 
considering the contribution from each cell separately. If we use $\Omega_c$ to signify
the region occupied by the cell $c \in \mathcal{C}$ and omit space-time arguments, this integral is 

\begin{equation}
\int_{\Omega_c} \diverg(\lambda \grad{\phi}) \dV = \int_{\Omega_c} \rho \dV.
\end{equation}

Using the Divergence Theorem, we integrate by parts to express the volume 
integral on the left-hand side in terms of a surface integral:

\begin{equation}
\int_{\Gamma_c} \lambda (\vec{n}\cdot\grad{\phi}) \dS = \int_{\Omega_c} \rho \dV \labelEq{fvDivThm}
\end{equation}

\noindent
where we have written $\Gamma_c$ as the boundary of the cell $c$, or the set 
of faces bounding the cell. If this cell lies in the interior of the domain, 
these faces separate the cell from its neighbors and they are planar facets. 
If $c$ is on the boundary, some of the cell's faces will represent the boundary, 
and we may opt to treat them in a more sophisticated way. We write 
$\Gamma_c = \bigcup(\Gamma_{ci}, \Gamma_{cb})$, where $\Gamma_{ci}$ is the set of 
``interior" faces of $c$ that separate two cells, and $\Gamma_{cb}$ is the set
of ``boundary" faces of $c$ that lie on the boundary $\partial\Omega$. This separates 
the left-hand side of \refEq{fvDivThm} into boundary and interior terms:

\begin{equation}
\int_{\Gamma_{cb}} \lambda (\vec{n}\cdot\grad{\phi}) \dS + 
\int_{\Gamma_{ci}} \lambda (\vec{n}\cdot\grad{\phi}) \dS = \int_{\Omega_c} \rho \dV. 
\end{equation}

\noindent
The integrand in the first term on the left-hand side then is evaluated for 
boundary cells by constructing an expression for $\lambda (\vec{n}\cdot\grad{\phi})$ on that 
part of the boundary, which involves enforcing the boundary conditions on $\Gamma_{cb}$. For mathematical
simplicity, we zero out the right-hand side by subtracting the $\rho$ term:

\begin{equation}
\int_{\Gamma_{cb}} \lambda (\vec{n}\cdot\grad{\phi}) \dS + 
\int_{\Gamma_{ci}} \lambda (\vec{n}\cdot\grad{\phi}) \dS - \int_{\Omega_c} \rho \dV = 0 \labelEq{fvContEq}
\end{equation}

\noindent
Solving this equation then consists of evaluating these integrals discretely in terms of the 
boundary conditions and the solution, constructing a nonlinear system of equations for 
the components of the solution vector, and solving that nonlinear problem.

\subsubsection*{Representation of the solution $\phi$}

Many finite volume methods represent the solution with a piecewise linear polynomial,
which allows them to take advantage of a number of mathematical coincidences. In this 
framework, the solution at the centroid of a cell is equal to the volume-averaged solution
in that cell:

\begin{equation}
\phi(\vec{x_c}, t) = \frac{\int_{\Omega_c} \phi(\vec{x}, t) \dV}{\int_{\Omega_c}\dV}
\end{equation}

\noindent
For higher-order spatial approximations, this relationship does not hold. We 
are interested in constructing least-squares polynomials that approximate $\phi$ 
everywhere in space given its values at a set of points (cell-centers, say). 
This representation allows us to compute $\phi$ and its gradient anywhere within a
cell, which we will need when we discretize \refEq{fvContEq}. 

Constructing a least-squares polynomial for $\phi$ in a given cell requires us to sample 
the values of $\phi$ in neighboring cells. \refTab{polyCoeffsVsOrder} shows the number of polynomial coefficients ($N$)
needed to represent a (scalar) solution in three dimensions for various polynomial orders. 
We can solve a system of $N$ normal equations to obtain these coefficients. To do this, we need at 
least $N$ neighbor values for $\phi$, but more is better. 

\begin{table}
 \centering
 \begin{tabular}{| l | c | r |} 
 \hline
 $p$ & $N$ \\
 \hline
 0 & 1 \\
 1 & 4 \\
 2 & 10 \\
 3 & 19 \\
 4 & 31 \\
 \hline
 \end{tabular}
 \caption{Number of polynomial coefficients $N$ for order $p$}
 \labelTab{polyCoeffsVsOrder}
\end{table}

Since a given cell $c$ has a fixed number of immediate neighbors, constructing a $p$th-order polynomial for $\phi$ within $c$ 
may require us to gather values from neighbors outside the immediate vicinity, which can be expensive. If we are not willing 
to pay this price, we can adopt a variable-order representation for $\phi$ that constructs higher-order polynomnials where 
there are more neighbors. Since interesting geometry in unstructured meshes tends to produce more connectivity, this idea 
has some intuitive appeal.

\subsubsection*{Unstructured mesh discretization}

Given that a cell $c$ is bounded by discrete faces, we can rewrite the surface integrals in \refEq{fvContEq} as sums over 
surface integrals involving those faces (leaving aside issues of numerical quadrature for the moment):

\begin{equation}
\sum_{f \in \Gamma_{cb}}\int_f \lambda (\vec{n}\cdot\grad{\phi}) \dS + 
\sum_{f \in \Gamma_{ci}}\int_f \lambda (\vec{n}\cdot\grad{\phi}) \dS - \int_{\Omega_c} \rho \dV = 0 
\end{equation}

\noindent
Given that we have a least-squares representation of $\phi$ and its gradient within the cell, we may now replace $\grad{\phi}$ 
in the first and second terms with this representation. Of course, in the first term, we need to first replace the 
integrand for each face $f$ with one that is consistent with the boundary condition on $f$.

We can treat the first term in the equation above using the corresponding procedures below:

\begin{itemize}
 \item On a face $f$ subject to a Dirichlet boundary condition, we can treat the first term in the following way. We replace $\vec{n}$ 
  with the normal vector for the face $f$. Then we can construct a least-squares fit for $\phi$ using the value $\phi_D$ on the face 
  center, and using the interior values of $\phi$ for the other least-squares samples. Then we can replace $\grad{\phi}$ with the 
  resulting polynomial expression and integrate.
 \item On a face subject to a Neumann boundary condition, we can replace the integrand by $\phi_N$ and integrate.
 \item On a face $f$ subject to a Robin boundary condition, we can follow the same procedure as for the Dirichlet boundary condition, 
  constructing the polynomial fit to the condition $\alpha\phi + \beta(\vec{n}\cdot\grad{\phi}) = \phi_R$, and then use the resulting 
  expression for $\vec{n}\cdot\grad{\phi}$ in the integral.
\end{itemize}

If $\int_\Omega \phi \dV$ is a conserved quantity, the quantity $\lambda(\vec{n}\cdot\grad{\phi})$ must be the same at all points
on the face, as seen by the cells on either side.

\subsubsection*{Numerical quadrature}

The numerical quadrature we use depends on the order of the least-squares representation of the solution. We can adopt any sufficiently
accurate rule that exactly reproduces polynomials.

\subsubsection*{Solution of nonlinear system}

The equation \refEq{fvContEq} gives us a nonlinear function $\vec{F}$ in the solution vector $\phi$:

\begin{equation}
\vec{F}(\phi) = \sum_{f \in \Gamma_{cb}}\int_f \lambda (\vec{n}\cdot\grad{\phi}) \dS + 
\sum_{f \in \Gamma_{ci}}\int_f \lambda (\vec{n}\cdot\grad{\phi}) \dS - \int_{\Omega_c} \rho \dV
\end{equation}

We can then construct the Jacobian of this function using finite-difference approximations and use a nonlinear solver 
to obtain sufficient accuracy.

Note that nonlinear forms of Poisson's equation--for example, those in which $\lambda$ and/or $\rho$ are functions of $\phi$ as well 
as $\vec{x}$ and $t$--can be used with this finite volume approach simply by using the polynomial representaton for $\phi$ wherever 
it is required.

\subsection{FVPM formulation}

In a finite volume particle method, the domain $\Omega$ is represented by a point cloud consisting of particles with corresponding 
subdomains $\{\Omega_i\}$ having compact support. These subdomains overlap with one another, so they do not partition $\Omega$.
In the most common version of the finite volume particle method found in the literature, a particle $i$ represents the solution using 
a test function of the sort

\begin{equation}
\psi(\vec{x}, t) = \frac{W_i}{\sum_{j=1}^N W_j}
\end{equation}

\noindent
where $W_i = W(\vec{x} - \vec{x}_i(t), h)$ is a compactly-supported kernel function centered at the particle's location $\vec{x}_i$, 
$h$ is (proportional to) the radius over which $W$ falls to zero, and the $W_j$ functions are functions corresponding to the neighbors 
of point $p$. More recently, it has been found that using a ``top-hat" test function (in which $W_i$ is 1 within $\Omega_i$ and drops 
abruptly to 0 outside it) simplifies the evaluation of integrals, and so we adopt this approach.

This method solves the model equation separately on the subdomain of each particle. To begin, we multiply \refEq{modelEq} by the test function $\psi_i$ and 
integrate over the subdomain $\Omega_i$ (the portion of $\Omega$ for which $\psi_i > 0$):

\begin{equation}
\int_{\Omega_i} \diverg(\lambda \grad{\phi}) \psi_i \dV = \int_{\Omega_c} \rho \psi_i \dV.
\end{equation}

As in the finite volume method, we continue by integrating the left-hand side by parts, though in this case we end up with both surface and
volume integrals because of the presence of the test function:

\begin{equation}
\int_{\Gamma_i} \lambda (\vec{n}\cdot\grad{\phi}) \psi_i \dS - 
\int_{\Omega_i} \lambda \grad{\phi}\cdot\grad{\psi_i} \dV = \int_{\Omega_c} \rho \psi_i \dV.
\end{equation}

\noindent
Here, we use notation similar to that in the finite volume method: $\Gamma_i$ is the boundary of the $i$th particle, which we can break into 
two parts: $\Gamma_{ii}$, the region in which $p$ interacts with other particles within $\Omega$, and $\Gamma_{ib}$, which is the region of
the subdomain that coincides with the domain boundary $\partial\Omega.$ However, 
in this case, the second term vanishes, since $\psi_i = 0$ on the boundary of $\Omega_i$.
Subtracting the right hand side as before, we have

\begin{equation}
\int_{\Gamma_{ib}} \lambda (\vec{n}\cdot\grad{\phi}) \psi_i \dS + 
\int_{\Omega_i} \lambda \grad{\phi}\cdot\grad{\psi_i} \dV - 
\int_{\Omega_c} \rho \psi_i \dV = 0, \labelEq{fvpmContEq}
\end{equation}

\noindent 
As in the finite volume method, the solution to \refEq{fvpmContEq} requires that we evaluate these integrals discretely in terms of the 
boundary conditions and the solution, after which we can use the same nonlinear solver machinery.

\subsubsection*{Representation of the solution $\phi$}

The solution $\phi$ is stored on the points in the point cloud and assumes its values exactly there (to whatever order our polynomial 
representation allows). When we are asked to evaluate $\phi$ within the vicinity of a given particle $p$, we construct a moving least-squares 
approximation of polynomial order $p$, and this requires us to sample values of the solution from points that neighbor $i$. 
Moving least squares representations have been used in various other mesh-free methods\cite{Dilts1999}.
The degree of the polynomial determines the extent of the neighbor search as before.

\subsubsection*{Spatial discretization}

If we use top-hat functions for $\psi$, we may write $1$ in place of $\psi$ within \refEq{fvpmContEq}.
Meanwhile, the volume integrals involving $\grad{\psi}$ are reduced to surface integrals with those 
gradients replaced by $-\vec{n}$, and we are left with

\begin{equation}
\int_{\Gamma_{ib}} \lambda (\vec{n}\cdot\grad{\phi}) \dS + 
\int_{\Gamma_i} \lambda (\vec{n}\cdot\grad{\phi}) \dS - 
\int_{\Omega_c} \rho \dV = 0. \labelEq{fvpmEqTopHat}
\end{equation}

Plugging in the moving least-squares representation $\grad{\phi}$
breaks the second term into a sum of integrals over spherical caps--the intersection of $\Omega_i$ with the various $\Omega_j$ subdomains of 
the neighboring points. Writing $\Gamma_i = \bigcup(\{\Gamma_{ij}\})$, where $\Gamma_{ij}$ is the area of intersection of the boundary of $\Gamma_i$
with the interior of $\Omega_j$, the subdomain of the neighboring particle $j$, we obtain

\begin{equation}
\int_{\Gamma_{ib}} \lambda (\vec{n}\cdot\grad{\phi}) \dS + 
\sum_j \int_{\Gamma_{ij}} \lambda (\vec{n}\cdot\grad{\phi}) \dS -
\int_{\Omega_c} \rho \dV = 0. \labelEq{fvpmEqTopHat}
\end{equation}

If $\int_\Omega \phi \dV$ is a conserved quantity, the integrals involving $i$ and $j$ in the second term must be the same as evaluated for 
points $i$ and $j$. To enforce boundary conditions in the first term. we use a procedure analogous to that given for the finite volume (FV) method.

\subsubsection*{Numerical quadrature}

The challenge in this method is to evaluate integrals on the surface of spheres and their intersections with other spheres. On the interior, the 
intersections $\Gamma_{ij}$ are spherical caps. Recently, Hesse has described polynomial-exact quadrature rules for integrals of this sort\cite{Hesse2012}.
For the boundary term, or the first term in \refEq{fvpmEqTopHat}, we have to be more careful, since the intersection of a sphere with a general boundary can 
be quite complicated.

The source term in \refEq{fvpmEqTopHat} must be evaluated over the interior of the spherical subdomain. We can experiment with various 
quadrature rules for this simple but compute-intensive task.

\section{Requirements}\labelSec{Requirements}

\section{Design}\labelSec{Design}

% Bibliography
\bibliography{references}
\bibliographystyle{plain}

\end{document} 
