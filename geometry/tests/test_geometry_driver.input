-- This tests the various geometry classes.

-- Make a coordinate mapping and try it out.
function ident_map_x(self, x)
  return x
end

function ident_map_v(self, x, v)
  return v
end

function ident_jac(self, x)
  return tensor2.new(1, 0, 0, 0, 1, 0, 0, 0, 1)
end

I = coord_mapping.new{name = "I",
                      map = ident_map_x, 
                      map_vector = ident_map_v, 
                      jacobian = ident_jac,
                      inverse = "self"}
x = point.new(1, 2, 3)
v = vector.new(4, 5, 6)
print(I) 
print(I(x)) 
print(I(x, v)) 
print(I:jacobian(x)) 
print(I:inverse()) 
print(I:metric(x))

-- Try out the shake-n-bake signed distance functions.
plane = sd_func.plane{normal = vector.new(1, 0, 0),
                      point = point.new(0, 0, 0)}
cyl = sd_func.cylinder{point = point.new(0, 0, 0),
                       radius = 1,
                       orientation = "inward"}
sph = sd_func.sphere{point = point.new(0, 0, 0),
                     radius = 1,
                     orientation = "inward"}
union = sd_func.union{plane, cyl, sph}
int = sd_func.intersection{plane, cyl, sph}
diff = sd_func.difference(cyl, sph)
print(plane, cyl, sph, union, int, diff)
x = point.new(0.5, 0.5, 0.5)
print(plane(x), cyl(x), sph(x), union(x), int(x), diff(x))
print(plane:grad(x), cyl:grad(x), sph:grad(x), union:grad(x), int:grad(x), diff:grad(x))
print(plane:project(x), cyl:project(x), sph:project(x), union:project(x), int:project(x), diff:project(x))

-- Now let's make our own plane function.
function pl1_value(self, x)
  n = vector.new(1, 0, 0)
  x0 = point.new(0, 0, 0)
  D = x - x0
  return vector.dot(D, n)
end

function pl1_grad(self, x)
  return vector.new(-1, 0, 0)
end

plane1 = sd_func.new{name = "my plane", 
                     value = pl1_value, 
                     grad = pl1_grad}
print(plane1)
plane1.name = 'your plane'
assert(plane1.name == 'your plane')
print(plane1(x))
print(plane1:grad(x))
print(plane1:project(x))

-- Now let's make a plane that moves to the right with speed 1.
function pl2_value(self, x, t)
  n = vector.new(1, 0, 0)
  x0 = point.new(t, 0, 0)
  D = x - x0
  return vector.dot(D, n)
end

function pl2_grad(self, x, t)
  return vector.new(t-1, 0, 0)
end

plane2 = sdt_func.new{name = "my moving plane", 
                      value = pl2_value, 
                      grad = pl2_grad}
print(plane2)
plane2.name = 'your moving plane'
assert(plane2.name == 'your moving plane')
print(plane2(x, 1))
print(plane2:grad(x, 1))
print(plane2:project(x, 1))

-- Uniform cartesian meshes.
box = bbox.new{x1 = 0, x2 = 1, y1 = 0, y2 = 1, z1 = 0, z2 = 1}
mesh = unimesh.new{comm = mpi.COMM_WORLD, bbox = box,
                   npx = 2, npy = 2, npz = 2, 
                   nx = 10, ny = 10, nz = 10}
sp = mesh.spacings
assert(reals_equal(sp[1], 0.05))
assert(reals_equal(sp[2], 0.05))
assert(reals_equal(sp[3], 0.05))
ex = mesh.extents
assert(ex[1] == 2)
assert(ex[2] == 2)
assert(ex[3] == 2)
ps = mesh.patch_size
assert(ps[1] == 10)
assert(ps[2] == 10)
assert(ps[3] == 10)
patches = mesh.patches
assert(#patches <= 8)

-- Polyhedral meshes.
mesh1 = polymesh.uniform{comm = mpi.COMM_WORLD, nx = 10, ny = 10, nz = 10, bbox = box}
print(mesh1.num_cells, mesh1.num_faces, mesh1.num_edges, mesh1.num_nodes)
mesh2 = polymesh.uniform{comm = mpi.COMM_WORLD, rank = 0, nx = 10, ny = 10, nz = 10, bbox = box}
if mpi.rank == 0 then
  assert(mesh2.num_cells == 1000)
end

xs = {0.1, 0.2, 0.3, 0.4, 0.5}
ys = xs
zs = xs
mesh3 = polymesh.rectilinear{comm = mpi.COMM_WORLD, xs = xs, ys = ys, zs = zs}
mesh4 = polymesh.rectilinear{comm = mpi.COMM_WORLD, rank = 0, xs = xs, ys = ys, zs = zs}

-- Force probe garbage collection.
collectgarbage("collect")
